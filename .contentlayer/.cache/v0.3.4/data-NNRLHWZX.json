{
  "cacheItemsMap": {
    "posts/an-alternative-to-vercel.mdx": {
      "document": {
        "title": "An Alternative to Vercel",
        "date": "2023-11-06T00:00:00.000Z",
        "slug": "an-alternative-to-vercel",
        "summary": "A Deep Dive into Serverless Stack (SST) for AWS Deployment",
        "featured": true,
        "body": {
          "raw": "\nIn the world of web development, deploying your projects quickly and efficiently is crucial. <a href=\"https://vercel.com/\" target=\"_blank\">Vercel</a>, a popular platform, has made this process a breeze for many developers. However, Vercel isn't without its limitations, especially when it comes to API execution time. In this blog post, we'll explore <a href=\"https://sst.dev/\" target=\"_blank\">SST</a> as an alternative that offers Infrastructure as Code (IaC) and direct deployment to AWS.\n\n## What is Vercel?\n\n<a href=\"https://vercel.com/\" target=\"_blank\">Vercel</a> is a cloud platform that streamlines the development and deployment of web applications and websites. It boasts an intuitive interface and offers a range of features, including serverless functions, static site hosting, continuous deployment, global content delivery, and collaboration tools. To add a project to Vercel, follow these simple steps:\n\n1. Sign in to your Vercel account or create one if you haven't already.\n2. Connect your project's Git repository to Vercel.\n3. Configure your project settings and choose your deployment branch.\n4. Vercel will automatically build and deploy your project.\n\n## Vercel's Limitations\n\n### API Time Limit\n\nOne of Vercel's primary limitations is its 10-second API execution time limit. While this restriction suits many use cases, it can be a significant hindrance for applications that require longer processing times or perform complex computations. If your project involves heavy server-side processing or data crunching that exceeds this time limit, Vercel might not be the ideal choice.\n\n### Cost\n\nVercel's pricing structure is based on usage, and while it can be cost-effective for small to medium-sized projects, it may not be the most budget-friendly option for very large applications or websites with high traffic. The usage-based model can lead to higher costs as your project scales, potentially limiting its affordability for larger endeavors.\n\n### No Direct Control Over Infrastructure\n\nVercel's user-friendly platform abstracts many of the underlying AWS infrastructure details, which simplifies deployment but can limit your ability to fine-tune AWS resources. If you require precise control over your AWS environment or have specific infrastructure configurations in mind, Vercel may not provide the level of customization you need.\n\n## An Alternative - SST\n\n<a href=\"https://sst.dev/\" target=\"_blank\">SST</a> is a tool designed to simplify the development of serverless applications on AWS. It addresses challenges associated with working directly with AWS Lambda, Amazon API Gateway, and other AWS services by enabling developers to define their infrastructure using AWS CDK, facilitating live testing and debugging with various IDEs, and offering a web-based dashboard for app management.\n<br/><br/> SST aims to streamline the process of creating and deploying serverless applications, supporting multiple programming languages for Lambda functions and higher-level constructs tailored for serverless development.From the SST docs \"SST converts your infrastructure code into a CloudFormation template using AWS CDK\" as seen in the figure below.\n\n<figure>\n  <img src=\"https://res.cloudinary.com/duud9d8dv/image/upload/v1699312090/how-cloudformation-works_nfpqj9.png\" alt=\"Cloud Formation Diagram\" class=\"rounded-lg\"/>\n  <figcaption class=\"flex text-center justify-center italic\">Figure 1. Diagram from <a class=\"ml-1\" href=\"https://sst.dev/chapters/what-is-infrastructure-as-code.html\" target=\"_blank\">SST Guide</a></figcaption>\n</figure>\n\n<a href=\"https://aws.amazon.com/pm/cloudformation/?trk=2dfe7cfe-88b0-4c42-844b-24167b0dc800&sc_channel=ps&ef_id=Cj0KCQiAuqKqBhDxARIsAFZELmKnqxH-9hb9KpqjtFTcF-Q46L2o7qwTW5PYOJ0AV3BEfyGnK_BpDQ4aAoQoEALw_wcB:G:s&s_kwcid=AL!4422!3!658520966117!!!g!!!19852661915!149878722180\" target=\"_blank\">AWS CloudFormation</a> is a service provided by Amazon Web Services (AWS) that simplifies and automates the process of provisioning and managing AWS resources. It allows developers and system administrators to define their infrastructure as code using templates, typically in YAML or JSON format. A drawback is lengthy templates that require manual definition of even minor resources, and it poses challenges for code reuse. And its use of YAML and JSON can also complicate handling large templates and requires a steep learning curve for resource definition.\n\nThat is where AWS CDK comes in. AWS Cloud Development Kit was a project launched in August 2018, that allows you to use modern programming languages like JavaScript or Python, instead of YAML or JSON. \n\n<figure>\n  <img src=\"https://res.cloudinary.com/duud9d8dv/image/upload/v1699313059/how-cdk-works_txkwpv.png\" alt=\"CDK Diagram\" class=\"rounded-lg\"/>\n  <figcaption class=\"flex text-center justify-center italic\">Figure 2. Diagram from <a class=\"ml-1\" href=\"https://sst.dev/chapters/what-is-aws-cdk.html\" target=\"_blank\">SST Guide</a></figcaption>\n</figure>\n\n\nSST simplifies serverless app development using higher-level CDK constructs, offering customization and a local development environment, integrating commands like \"sst build\" and \"sst deploy\".\n\n## SST File Structure \nThere are two types of file structure when it comes to using SST in a project, Drop-in Mode and Monorepo.\n\n### Drop-in Mode\nIn drop-in mode, SST can be used as part of your frontend app. For example, if you run npm create sst inside a Next.js app, it'll drop a sst.config.ts in your project. This is great if you have a simple Next.js app and you just want to deploy it to AWS with SST. The directory structure in drop-in mode might look like this:\n\n```\nmy-nextjs-app  \n├─ next.config.js  \n├─ sst.config.ts  \n├─ package.json  \n├─ public  \n├─ styles  \n└─ pages  \n```\n### Monorepo\n A monorepo setup is recommended as it's the best way to manage a growing project with interconnected parts like the backend, frontend, and infrastructure. In this structure, you can add your frontend to the packages/web/ directory, packages/functions/ are for backend functions, packages/core/ is for any shared business logic, and stacks/ has your infrastructure definitions. The directory structure in monorepo mode might look like this:\n\n```\nmy-sst-app  \n├─ package.json  \n├─ sst.config.ts  \n├─ packages  \n│  ├─ core  \n│  │ └─ migrations  \n│  ├─ functions  \n│  ├─ graphql  \n│  └─ web  \n└─ stacks  \n```\n\n",
          "html": "<p>In the world of web development, deploying your projects quickly and efficiently is crucial. Vercel, a popular platform, has made this process a breeze for many developers. However, Vercel isn't without its limitations, especially when it comes to API execution time. In this blog post, we'll explore SST as an alternative that offers Infrastructure as Code (IaC) and direct deployment to AWS.</p>\n<h2>What is Vercel?</h2>\n<p>Vercel is a cloud platform that streamlines the development and deployment of web applications and websites. It boasts an intuitive interface and offers a range of features, including serverless functions, static site hosting, continuous deployment, global content delivery, and collaboration tools. To add a project to Vercel, follow these simple steps:</p>\n<ol>\n<li>Sign in to your Vercel account or create one if you haven't already.</li>\n<li>Connect your project's Git repository to Vercel.</li>\n<li>Configure your project settings and choose your deployment branch.</li>\n<li>Vercel will automatically build and deploy your project.</li>\n</ol>\n<h2>Vercel's Limitations</h2>\n<h3>API Time Limit</h3>\n<p>One of Vercel's primary limitations is its 10-second API execution time limit. While this restriction suits many use cases, it can be a significant hindrance for applications that require longer processing times or perform complex computations. If your project involves heavy server-side processing or data crunching that exceeds this time limit, Vercel might not be the ideal choice.</p>\n<h3>Cost</h3>\n<p>Vercel's pricing structure is based on usage, and while it can be cost-effective for small to medium-sized projects, it may not be the most budget-friendly option for very large applications or websites with high traffic. The usage-based model can lead to higher costs as your project scales, potentially limiting its affordability for larger endeavors.</p>\n<h3>No Direct Control Over Infrastructure</h3>\n<p>Vercel's user-friendly platform abstracts many of the underlying AWS infrastructure details, which simplifies deployment but can limit your ability to fine-tune AWS resources. If you require precise control over your AWS environment or have specific infrastructure configurations in mind, Vercel may not provide the level of customization you need.</p>\n<h2>An Alternative - SST</h2>\n<p>SST is a tool designed to simplify the development of serverless applications on AWS. It addresses challenges associated with working directly with AWS Lambda, Amazon API Gateway, and other AWS services by enabling developers to define their infrastructure using AWS CDK, facilitating live testing and debugging with various IDEs, and offering a web-based dashboard for app management.\n SST aims to streamline the process of creating and deploying serverless applications, supporting multiple programming languages for Lambda functions and higher-level constructs tailored for serverless development.From the SST docs \"SST converts your infrastructure code into a CloudFormation template using AWS CDK\" as seen in the figure below.</p>\n<p>AWS CloudFormation is a service provided by Amazon Web Services (AWS) that simplifies and automates the process of provisioning and managing AWS resources. It allows developers and system administrators to define their infrastructure as code using templates, typically in YAML or JSON format. A drawback is lengthy templates that require manual definition of even minor resources, and it poses challenges for code reuse. And its use of YAML and JSON can also complicate handling large templates and requires a steep learning curve for resource definition.</p>\n<p>That is where AWS CDK comes in. AWS Cloud Development Kit was a project launched in August 2018, that allows you to use modern programming languages like JavaScript or Python, instead of YAML or JSON.</p>\n<p>SST simplifies serverless app development using higher-level CDK constructs, offering customization and a local development environment, integrating commands like \"sst build\" and \"sst deploy\".</p>\n<h2>SST File Structure</h2>\n<p>There are two types of file structure when it comes to using SST in a project, Drop-in Mode and Monorepo.</p>\n<h3>Drop-in Mode</h3>\n<p>In drop-in mode, SST can be used as part of your frontend app. For example, if you run npm create sst inside a Next.js app, it'll drop a sst.config.ts in your project. This is great if you have a simple Next.js app and you just want to deploy it to AWS with SST. The directory structure in drop-in mode might look like this:</p>\n<pre><code>my-nextjs-app  \n├─ next.config.js  \n├─ sst.config.ts  \n├─ package.json  \n├─ public  \n├─ styles  \n└─ pages  \n</code></pre>\n<h3>Monorepo</h3>\n<p>A monorepo setup is recommended as it's the best way to manage a growing project with interconnected parts like the backend, frontend, and infrastructure. In this structure, you can add your frontend to the packages/web/ directory, packages/functions/ are for backend functions, packages/core/ is for any shared business logic, and stacks/ has your infrastructure definitions. The directory structure in monorepo mode might look like this:</p>\n<pre><code>my-sst-app  \n├─ package.json  \n├─ sst.config.ts  \n├─ packages  \n│  ├─ core  \n│  │ └─ migrations  \n│  ├─ functions  \n│  ├─ graphql  \n│  └─ web  \n└─ stacks  \n</code></pre>"
        },
        "_id": "posts/an-alternative-to-vercel.mdx",
        "_raw": {
          "sourceFilePath": "posts/an-alternative-to-vercel.mdx",
          "sourceFileName": "an-alternative-to-vercel.mdx",
          "sourceFileDir": "posts",
          "contentType": "mdx",
          "flattenedPath": "posts/an-alternative-to-vercel"
        },
        "type": "Posts"
      },
      "documentHash": "1705565578042",
      "hasWarnings": false,
      "documentTypeName": "Posts"
    },
    "posts/how-to-build-a-product-not-a-project.mdx": {
      "document": {
        "title": "How to Build a Product, Not a Project",
        "date": "2023-10-01T00:00:00.000Z",
        "slug": "how-to-build-a-product-not-a-project",
        "summary": "I write about what I have learned while building projects.",
        "featured": true,
        "body": {
          "raw": "\n## The Developer's Dilemma\n\nDo you ever find yourself in the familiar developer's dilemma? You start a project with enthusiasm and creativity, only for it to languish, half-finished, in a digital graveyard. You're not alone. In the world of software development, this is a scenario that plagues many aspiring creators. You might have a brilliant idea, the coding skills, and the motivation to start, but finishing? That's where the struggle often lies.\n\nThe truth is, if you want your project to evolve into a successful product, simply starting it and coding your way through won't cut it in the long term. To prevent your efforts from becoming yet another unfinished project, there are essential questions you need to ask yourself before even writing the first line of code.\n\n### The Questions You Need to Ask\n\n#### 1. What Problem Are You Solving?\n\nBefore you embark on any development journey, you must be clear about the problem you intend to solve. What pain points or challenges do you aim to address with your project? Are you creating a solution for a real, pressing issue? The clearer your problem statement, the more focused and effective your development will be.\n\n#### 2. Who Are You Building It For?\n\nUnderstanding your target audience is fundamental. Your project should cater to a specific group of users. Who are they? What are their needs, preferences, and behaviors? You should create user personas to help you visualize the people who will benefit from your product. This information is invaluable when designing and developing features that resonate with your intended users.\n\n#### 3. Why Would People Pay Money to Use It?\n\nMonetization is a critical aspect of turning a project into a product. You need to identify your product's unique value proposition – what sets it apart from existing solutions? What benefits will users gain that are compelling enough to open their wallets? Without a clear understanding of the value you offer, it's challenging to create a sustainable business around your creation.\n\nBy answering these questions before you even start coding, you set the foundation for a product-driven approach. You ensure that your development efforts are aligned with a meaningful purpose, a defined audience, and a solid revenue strategy. This approach not only increases the likelihood of your project's completion but also maximizes its potential for success.\n\nIn this post, we'll explore strategies to help you navigate these essential questions and guide your project on a path toward becoming a fully realized, marketable product.\n\n## Reverse Engineering the Final Product\n\nOnce you've answered the fundamental questions about the problem you're solving, your target audience, and the value you provide, it's time to take a step back from coding. The mistake many developers make is rushing into writing code without a clear understanding of what the final product will look like. Without a well-defined roadmap, you risk building something without a coherent direction.\n\n### Visualize the User Flow\n\nStart by visualizing the user's journey through your product. Map out the steps they'll take from the moment they land on your platform to when they achieve their goal. Consider the user's interaction points, the decisions they'll make, and the paths they can take. Understanding the user flow helps you design a seamless and intuitive experience.\n\n### Design the Pages\n\nWith the user flow in mind, sketch out the pages and screens that will make up your product. Consider the layout, content, and functionality of each page. Pay attention to the user interface (UI) design and user experience (UX) principles. This step is crucial because it helps you create a user-friendly and visually appealing product.\n\n### Create Wireframes and Prototypes\n\nBefore you jump into development, create wireframes and prototypes. Wireframes are simple, low-fidelity sketches of your pages, outlining the structure and placement of elements. Prototypes, on the other hand, are interactive representations of your product's functionality. They allow you to test and refine your design concepts without writing a single line of code.\n\n### Define Milestones\n\nBreak down your project into milestones. Each milestone represents a significant step toward your final product. By setting these checkpoints, you can track your progress and ensure you're on the right path. It also makes it easier to adjust your course if necessary.\n\nBy thoroughly visualizing the user flow, designing the pages, creating wireframes and prototypes, getting feedback, and defining milestones, you establish a solid foundation for your project. This thoughtful approach not only saves you from heading in the wrong direction but also makes the development process more efficient and focused. Now, you're ready to code with a clear vision of the final product in mind.\n\n## Building the MVP\n\nWith a clear design and user flow in hand, you can now begin building your Minimum Viable Product (MVP). The MVP is a stripped-down version of your final product that includes essential features and functionality. It's not about building everything at once but rather delivering a usable product quickly.\n\n### Launch and Share\n\nOnce your MVP is ready, launch it and share it on relevant platforms and social media channels. Encourage users to try it out and provide feedback. An early release allows you to gauge interest and gather insights into how users interact with your product.\n\n### Gather User Feedback\n\nActively seek user feedback and listen to their experiences. What do they like? What needs improvement? Are there features they would love to see? User feedback is a goldmine of information that can guide your development efforts.\n\n### Iterate and Improve\n\nBased on the feedback you receive, make iterative improvements to your MVP. Prioritize enhancements that align with your initial vision and user needs. The agile development approach allows you to adapt quickly and respond to changing requirements.\n\n### Set Clear Goals\n\nAs you iterate, set clear goals for each development cycle. Whether it's adding new features, enhancing the user interface, or optimizing performance, having defined objectives helps you measure progress and maintain focus.\n\nBy following this iterative approach, you gradually evolve your project into a product that aligns with user expectations and demands. It ensures that you don't waste time building features that aren't valuable to your audience and, instead, focus on what truly matters.\n\n## Conclusion\n\nTurning your project into a successful product is an achievable goal, but it requires careful planning, user-focused design, and an iterative development process. By answering essential questions, reverse engineering the final product, building an MVP, and continuously gathering and acting upon user feedback, you increase the likelihood of creating a product that people will use and value. Remember, the journey may be challenging, but with the right approach, your project can transform into a product that thrives in the market.\n",
          "html": "<h2>The Developer's Dilemma</h2>\n<p>Do you ever find yourself in the familiar developer's dilemma? You start a project with enthusiasm and creativity, only for it to languish, half-finished, in a digital graveyard. You're not alone. In the world of software development, this is a scenario that plagues many aspiring creators. You might have a brilliant idea, the coding skills, and the motivation to start, but finishing? That's where the struggle often lies.</p>\n<p>The truth is, if you want your project to evolve into a successful product, simply starting it and coding your way through won't cut it in the long term. To prevent your efforts from becoming yet another unfinished project, there are essential questions you need to ask yourself before even writing the first line of code.</p>\n<h3>The Questions You Need to Ask</h3>\n<h4>1. What Problem Are You Solving?</h4>\n<p>Before you embark on any development journey, you must be clear about the problem you intend to solve. What pain points or challenges do you aim to address with your project? Are you creating a solution for a real, pressing issue? The clearer your problem statement, the more focused and effective your development will be.</p>\n<h4>2. Who Are You Building It For?</h4>\n<p>Understanding your target audience is fundamental. Your project should cater to a specific group of users. Who are they? What are their needs, preferences, and behaviors? You should create user personas to help you visualize the people who will benefit from your product. This information is invaluable when designing and developing features that resonate with your intended users.</p>\n<h4>3. Why Would People Pay Money to Use It?</h4>\n<p>Monetization is a critical aspect of turning a project into a product. You need to identify your product's unique value proposition – what sets it apart from existing solutions? What benefits will users gain that are compelling enough to open their wallets? Without a clear understanding of the value you offer, it's challenging to create a sustainable business around your creation.</p>\n<p>By answering these questions before you even start coding, you set the foundation for a product-driven approach. You ensure that your development efforts are aligned with a meaningful purpose, a defined audience, and a solid revenue strategy. This approach not only increases the likelihood of your project's completion but also maximizes its potential for success.</p>\n<p>In this post, we'll explore strategies to help you navigate these essential questions and guide your project on a path toward becoming a fully realized, marketable product.</p>\n<h2>Reverse Engineering the Final Product</h2>\n<p>Once you've answered the fundamental questions about the problem you're solving, your target audience, and the value you provide, it's time to take a step back from coding. The mistake many developers make is rushing into writing code without a clear understanding of what the final product will look like. Without a well-defined roadmap, you risk building something without a coherent direction.</p>\n<h3>Visualize the User Flow</h3>\n<p>Start by visualizing the user's journey through your product. Map out the steps they'll take from the moment they land on your platform to when they achieve their goal. Consider the user's interaction points, the decisions they'll make, and the paths they can take. Understanding the user flow helps you design a seamless and intuitive experience.</p>\n<h3>Design the Pages</h3>\n<p>With the user flow in mind, sketch out the pages and screens that will make up your product. Consider the layout, content, and functionality of each page. Pay attention to the user interface (UI) design and user experience (UX) principles. This step is crucial because it helps you create a user-friendly and visually appealing product.</p>\n<h3>Create Wireframes and Prototypes</h3>\n<p>Before you jump into development, create wireframes and prototypes. Wireframes are simple, low-fidelity sketches of your pages, outlining the structure and placement of elements. Prototypes, on the other hand, are interactive representations of your product's functionality. They allow you to test and refine your design concepts without writing a single line of code.</p>\n<h3>Define Milestones</h3>\n<p>Break down your project into milestones. Each milestone represents a significant step toward your final product. By setting these checkpoints, you can track your progress and ensure you're on the right path. It also makes it easier to adjust your course if necessary.</p>\n<p>By thoroughly visualizing the user flow, designing the pages, creating wireframes and prototypes, getting feedback, and defining milestones, you establish a solid foundation for your project. This thoughtful approach not only saves you from heading in the wrong direction but also makes the development process more efficient and focused. Now, you're ready to code with a clear vision of the final product in mind.</p>\n<h2>Building the MVP</h2>\n<p>With a clear design and user flow in hand, you can now begin building your Minimum Viable Product (MVP). The MVP is a stripped-down version of your final product that includes essential features and functionality. It's not about building everything at once but rather delivering a usable product quickly.</p>\n<h3>Launch and Share</h3>\n<p>Once your MVP is ready, launch it and share it on relevant platforms and social media channels. Encourage users to try it out and provide feedback. An early release allows you to gauge interest and gather insights into how users interact with your product.</p>\n<h3>Gather User Feedback</h3>\n<p>Actively seek user feedback and listen to their experiences. What do they like? What needs improvement? Are there features they would love to see? User feedback is a goldmine of information that can guide your development efforts.</p>\n<h3>Iterate and Improve</h3>\n<p>Based on the feedback you receive, make iterative improvements to your MVP. Prioritize enhancements that align with your initial vision and user needs. The agile development approach allows you to adapt quickly and respond to changing requirements.</p>\n<h3>Set Clear Goals</h3>\n<p>As you iterate, set clear goals for each development cycle. Whether it's adding new features, enhancing the user interface, or optimizing performance, having defined objectives helps you measure progress and maintain focus.</p>\n<p>By following this iterative approach, you gradually evolve your project into a product that aligns with user expectations and demands. It ensures that you don't waste time building features that aren't valuable to your audience and, instead, focus on what truly matters.</p>\n<h2>Conclusion</h2>\n<p>Turning your project into a successful product is an achievable goal, but it requires careful planning, user-focused design, and an iterative development process. By answering essential questions, reverse engineering the final product, building an MVP, and continuously gathering and acting upon user feedback, you increase the likelihood of creating a product that people will use and value. Remember, the journey may be challenging, but with the right approach, your project can transform into a product that thrives in the market.</p>"
        },
        "_id": "posts/how-to-build-a-product-not-a-project.mdx",
        "_raw": {
          "sourceFilePath": "posts/how-to-build-a-product-not-a-project.mdx",
          "sourceFileName": "how-to-build-a-product-not-a-project.mdx",
          "sourceFileDir": "posts",
          "contentType": "mdx",
          "flattenedPath": "posts/how-to-build-a-product-not-a-project"
        },
        "type": "Posts"
      },
      "documentHash": "1705565579944",
      "hasWarnings": false,
      "documentTypeName": "Posts"
    },
    "posts/most-used-git-commands.mdx": {
      "document": {
        "title": "Most Used Git Commands",
        "date": "2024-01-09T00:00:00.000Z",
        "slug": "most-used-git-commands",
        "summary": "Here are some commands I constantly have to search up, in one place.",
        "featured": true,
        "body": {
          "raw": "\nHere are some of the most commonly use git commands I use. Wanted to put it in one place to reference back to whenever.\n\n### Amend an unpushed commit message \n\n```js title=\"Terminal\"\ngit commit --amend\n```\n\n### Delete a branch locally\n\n```js title=\"Terminal\"\ngit branch -d localBranchName\n```\n\n### Delete a branch remotely\n\n```js title=\"Terminal\"\ngit push origin --delete remoteBranchName\n```\n\n### Remove commit based on commit history position\n\n```js title=\"Terminal\"\ngit reset --hard HEAD~1\n```\n\n### Remove .env from GitHub\n\n```js title=\"Terminal\"\ngit rm -r --cached .env\ngit commit -m 'untracking .env'\ngit push origin master\n```\n",
          "html": "<p>Here are some of the most commonly use git commands I use. Wanted to put it in one place to reference back to whenever.</p>\n<h3>Amend an unpushed commit message</h3>\n<pre><code class=\"language-js\">git commit --amend\n</code></pre>\n<h3>Delete a branch locally</h3>\n<pre><code class=\"language-js\">git branch -d localBranchName\n</code></pre>\n<h3>Delete a branch remotely</h3>\n<pre><code class=\"language-js\">git push origin --delete remoteBranchName\n</code></pre>\n<h3>Remove commit based on commit history position</h3>\n<pre><code class=\"language-js\">git reset --hard HEAD~1\n</code></pre>\n<h3>Remove .env from GitHub</h3>\n<pre><code class=\"language-js\">git rm -r --cached .env\ngit commit -m 'untracking .env'\ngit push origin master\n</code></pre>"
        },
        "_id": "posts/most-used-git-commands.mdx",
        "_raw": {
          "sourceFilePath": "posts/most-used-git-commands.mdx",
          "sourceFileName": "most-used-git-commands.mdx",
          "sourceFileDir": "posts",
          "contentType": "mdx",
          "flattenedPath": "posts/most-used-git-commands"
        },
        "type": "Posts"
      },
      "documentHash": "1705567236075",
      "hasWarnings": false,
      "documentTypeName": "Posts"
    },
    "posts/why-i-pivoted-from-hardware-to-software.mdx": {
      "document": {
        "title": "Why I Pivoted from Hardware to Software",
        "date": "2023-10-02T00:00:00.000Z",
        "slug": "why-i-pivoted-from-hardware-to-software",
        "summary": "Exploring my switch from hardware to software engineering and the factors that influenced my decision.",
        "featured": false,
        "body": {
          "raw": "\n## My Educational Journey\n\nIn university, I majored in **Computer Engineering**. It is a combination of both electrical and software engineering. I always knew I wanted to go into the engineering field but wasn't sure which route to go.\n\n### Exploring My Options\n\n- Should I study to be a **Petroleum Engineer** because they make a lot of money?\n- Should I do **Mechanical Engineering** because I get to physically build stuff?\n- Should I do **Civil Engineering** because it's more stable, and I can pursue government jobs?\n\nI ended up going with Computer Engineering because I knew I loved programming, and it was the future, but I didn't want to sit in front of a desk all day.\n\n### Specialization Choices\n\nIn my last year, I had to specialize more on hardware because it was the quickest way for me to graduate. If I knew better, I would've realized early on that in order to do the software specialization, I would've taken the appropriate classes. But I didn't, so I went with whatever was handed to me. So I was able to graduate fast.\n\n### The Internship Dilemma\n\nI had a couple of internships, and they were mostly software-focused. I wanted to try a hardware job, but it was impossible to get a role like that without hardware experience, which is the norm in this field. It's a chicken and egg situation. Companies want you to have experience, but you need an opportunity to gain it. So most of the time for entry-level jobs, it's your future manager taking a chance on you. So that is what happened to me.\n\n### My First Job\n\nMy first position was a **Software Engineering** role. That's where I learned more about Python and grew my HTML and CSS skills. However, most of the projects we were working on weren't optimized or up to date with the latest tech stacks. So I felt if I stayed there longer, I wouldn't grow my skills, so I quit.\n\n### Discovering My Path\n\nI tried again to look for hardware positions and luckily got an opportunity at a startup as an **Associate Embedded Systems Engineer**. I learned a lot, the main thing being that I wanted to do software and not hardware. I realized how much time I was wasting driving to the office, and I could stay at home if I only did the software side of things. So I left that job and took a year to learn more web development and mobile development skills. And haven't looked back since.\n\n## Hardware vs. Software: Pros and Cons\n\n### Working in Hardware\n\n#### Pros:\n\n- **Tangible Creations**: Working on hardware allows you to physically build and create products that you can touch and see.\n- **Engineering Challenges**: Hardware engineering often presents unique and challenging problems related to electronics, materials, and physical design.\n- **Stability**: Hardware jobs are often considered stable and are crucial in many industries, such as manufacturing and telecommunications.\n\n#### Cons:\n\n- **Limited Flexibility**: Hardware projects are often more rigid and may involve lengthy development cycles, making it harder to quickly adapt to changes.\n- **Higher Costs**: Developing hardware can be costly due to the need for physical components, prototypes, and manufacturing processes.\n- **Lack of Remote Work**: Hardware work often requires a physical presence in labs or manufacturing facilities, limiting the possibility of remote work.\n\n### Working in Software\n\n#### Pros:\n\n- **Versatility**: Software development offers a wide range of opportunities, from web and mobile applications to AI and game development.\n- **Fast Iteration**: Software projects can evolve rapidly, allowing for quick adjustments and updates in response to changing requirements.\n- **Remote Work**: Many software jobs can be done remotely, offering flexibility in terms of location and work arrangements.\n\n#### Cons:\n\n- **Lack of Tangibility**: Software is intangible, which means your creations are not physical objects you can touch.\n- **High Competition**: The software industry is highly competitive, and staying up to date with evolving technologies is crucial.\n- **Sedentary Work**: Software development often involves long hours in front of a computer, which can be physically demanding in a different way.\n",
          "html": "<h2>My Educational Journey</h2>\n<p>In university, I majored in <strong>Computer Engineering</strong>. It is a combination of both electrical and software engineering. I always knew I wanted to go into the engineering field but wasn't sure which route to go.</p>\n<h3>Exploring My Options</h3>\n<ul>\n<li>Should I study to be a <strong>Petroleum Engineer</strong> because they make a lot of money?</li>\n<li>Should I do <strong>Mechanical Engineering</strong> because I get to physically build stuff?</li>\n<li>Should I do <strong>Civil Engineering</strong> because it's more stable, and I can pursue government jobs?</li>\n</ul>\n<p>I ended up going with Computer Engineering because I knew I loved programming, and it was the future, but I didn't want to sit in front of a desk all day.</p>\n<h3>Specialization Choices</h3>\n<p>In my last year, I had to specialize more on hardware because it was the quickest way for me to graduate. If I knew better, I would've realized early on that in order to do the software specialization, I would've taken the appropriate classes. But I didn't, so I went with whatever was handed to me. So I was able to graduate fast.</p>\n<h3>The Internship Dilemma</h3>\n<p>I had a couple of internships, and they were mostly software-focused. I wanted to try a hardware job, but it was impossible to get a role like that without hardware experience, which is the norm in this field. It's a chicken and egg situation. Companies want you to have experience, but you need an opportunity to gain it. So most of the time for entry-level jobs, it's your future manager taking a chance on you. So that is what happened to me.</p>\n<h3>My First Job</h3>\n<p>My first position was a <strong>Software Engineering</strong> role. That's where I learned more about Python and grew my HTML and CSS skills. However, most of the projects we were working on weren't optimized or up to date with the latest tech stacks. So I felt if I stayed there longer, I wouldn't grow my skills, so I quit.</p>\n<h3>Discovering My Path</h3>\n<p>I tried again to look for hardware positions and luckily got an opportunity at a startup as an <strong>Associate Embedded Systems Engineer</strong>. I learned a lot, the main thing being that I wanted to do software and not hardware. I realized how much time I was wasting driving to the office, and I could stay at home if I only did the software side of things. So I left that job and took a year to learn more web development and mobile development skills. And haven't looked back since.</p>\n<h2>Hardware vs. Software: Pros and Cons</h2>\n<h3>Working in Hardware</h3>\n<h4>Pros:</h4>\n<ul>\n<li><strong>Tangible Creations</strong>: Working on hardware allows you to physically build and create products that you can touch and see.</li>\n<li><strong>Engineering Challenges</strong>: Hardware engineering often presents unique and challenging problems related to electronics, materials, and physical design.</li>\n<li><strong>Stability</strong>: Hardware jobs are often considered stable and are crucial in many industries, such as manufacturing and telecommunications.</li>\n</ul>\n<h4>Cons:</h4>\n<ul>\n<li><strong>Limited Flexibility</strong>: Hardware projects are often more rigid and may involve lengthy development cycles, making it harder to quickly adapt to changes.</li>\n<li><strong>Higher Costs</strong>: Developing hardware can be costly due to the need for physical components, prototypes, and manufacturing processes.</li>\n<li><strong>Lack of Remote Work</strong>: Hardware work often requires a physical presence in labs or manufacturing facilities, limiting the possibility of remote work.</li>\n</ul>\n<h3>Working in Software</h3>\n<h4>Pros:</h4>\n<ul>\n<li><strong>Versatility</strong>: Software development offers a wide range of opportunities, from web and mobile applications to AI and game development.</li>\n<li><strong>Fast Iteration</strong>: Software projects can evolve rapidly, allowing for quick adjustments and updates in response to changing requirements.</li>\n<li><strong>Remote Work</strong>: Many software jobs can be done remotely, offering flexibility in terms of location and work arrangements.</li>\n</ul>\n<h4>Cons:</h4>\n<ul>\n<li><strong>Lack of Tangibility</strong>: Software is intangible, which means your creations are not physical objects you can touch.</li>\n<li><strong>High Competition</strong>: The software industry is highly competitive, and staying up to date with evolving technologies is crucial.</li>\n<li><strong>Sedentary Work</strong>: Software development often involves long hours in front of a computer, which can be physically demanding in a different way.</li>\n</ul>"
        },
        "_id": "posts/why-i-pivoted-from-hardware-to-software.mdx",
        "_raw": {
          "sourceFilePath": "posts/why-i-pivoted-from-hardware-to-software.mdx",
          "sourceFileName": "why-i-pivoted-from-hardware-to-software.mdx",
          "sourceFileDir": "posts",
          "contentType": "mdx",
          "flattenedPath": "posts/why-i-pivoted-from-hardware-to-software"
        },
        "type": "Posts"
      },
      "documentHash": "1705567314498",
      "hasWarnings": false,
      "documentTypeName": "Posts"
    }
  }
}
